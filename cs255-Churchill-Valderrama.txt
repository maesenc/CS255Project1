Encrypt: Encrypt gets the group key from storage (storage described in SaveKeys and LoadKeys)
and creates a random 128-bit IV.  The group key is then used to encrypt the message blocks
with the IV in counter mode, using AES.  The one minor change that we made to the construction
shown in class was to increment only the last 32-bit integer in the 128-bit IV, rather than 
the entire 128-bit IV treated as a single number, in encrypting subsequent message blocks.
Other than that, we follow the procedure shown in class, and prepend the IV to the ciphertext.

However, this is fine.  We don't risk wrap the IV wrapping around to the same value after
encrypting 2^32 message blocks, because facebook limits message sizes (and the actual maximum
length of a single message is much shorter than 2^32 * 128 bits).  Thus, we can apply the 
counter-mode Theorem from lecture to our encryption scheme.  Assuming AES with our group key
is a secure PRF, our encryption scheme is secure to encrypt up to 2^32 messages.

AES is thought to be a secure PRF, and our group key is a random string.  As long as the group
key is stored securely, our encryption scheme is secure.

Decrypt: Decrypt follows the decryption algorithm for random counter mode.  The IV is obtained 
from the first 128 bits of the ciphertext.  The group key is pulled from storage.  AES is done
on the IV with the group key and xor'd with the first message block.  The last 32-bit integer
of the IV is incrememted, and the process is repeated to decrypt each additional message block.

GenerateKey: Each group key is generated by querying GetRandomValues for a 128-bit string.  
After generation, the key is stored in the key map.

SaveKeys: SaveKeys first obtains the database key from session storage.  This key is used
to encrypt the group keys and save them to local storage.
A new map from group names to encrypted group keys is created.  Each group key in the map 
is encrypted using the database key and AES.  A new entry in the encrypted map is created,
mapping the group name to this encrypted key.  Once every member of the keys map has been
added, the encrypted map is stored as a string to local storage.

As is described in LoadKeys, the database key is also encrypted before being stored in local
storage.  Thus, in order to obtain any group key, an attacker would have to break AES.

LoadKeys: LoadKeys has three cases -- 1. The user has already entered the database password
and it is in session storage, 2. The user has not yet set a database key, and 3. The user 
set database key, but has yet to enter it in this session.

In case 1, LoadKeys simply uses the database key in secure session storage to decrypt
the encrypted key map saved to local storage (see SaveKeys).  The decrypted group keys are stored
in the keys map.

In case 2, the user is promped to set a database password of their choice.  A random 128-bit 
salt is chosen by a call to GetRandomValues.  The salt is stored on local storage.  The provided
key generation function is then used to create a 128-bit database key from the salt and password.
The database key is stored in session storage.  It is also stored in local storage once it has been
encrypted, using itself as a key, using AES.

In case 3, the user is promped for the database password they selected.  Once a password is entered,
the user's salt is taken from local storage and AES is conducted on the temporary key made
from the entered password and the salt.  If this encrypted value matches the encrypted database
key stored in local storage, the database key is stored in session storage. The keys for each group 
are taken from local storage, decrypted using AES and the database key and stored in the keys map.  
If the encrypted value does not match the entered key, the user is reprompted for the password.

Because AES is presumed to be secure, the only way an attacker could obtain the keys is to
guess the database password.  We here note that since the salts are stored in the open
in local storage, the keys used to encrypt database keys for storage (that is, the concatination 
of salts and user-entered database passwords) are NOT random 128-bit strings.  If an attacker
can guess the user's database password, they can decrypt the group keys, so guessing common
passwords would be an attack more efficient than exaustive search of 128-bit keys.

The random salts are assigned when database passwords are created, which prevents an attacker
from making a table of encrypted database keys from common passwords beforehand.  However, there
is still a burden placed on the user to create a secure database password and keep it secret.

-----------------

Additional questions:

1. One of the big issues with doing cryptography in a browser is that if the browser
is compromised, the entire system is compromised.  For example, if an attacker was able to 
take over the browser during a session and access the database key, the could access all
of the user's group keys.  Such browser attacks are not uncommon.  We still want to use
cryptography in a browser because it does have the potential to be secure most situations.
It protects from many other common attacks, and it works most of the time.  This isn't ideal,
but it is still better than nothing.  It limits the attacks that can take place.  Browser
cryptography is useful in the same way that a home alarm system is meant to keep out
the common criminal, but is not particuarly useful against highly professional
attacks.

2. The way we do comparisons between a database key created from a user's entered password and 
the database key stored in local storage is vulnerable to a subtle side-channel attack: if an
attacker could distinguish between the time JavaScript takes to evaluate equality versus the 
time JavaScript takes to evaluate inequality, they could tell how far off their entered password
was from the database password, when encrypted with AES.
Our system is also vulnerable to a brute-force attack, trying different passwords.






